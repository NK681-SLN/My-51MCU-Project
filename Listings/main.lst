C51 COMPILER V9.60.7.0   MAIN                                                              01/30/2026 14:36:05 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "reg52.h"
   2          #include "public.h"
   3          #include "smg.h"
   4          #include "EEPROM.h"
   5          #include <string.h>
   6          #include <intrins.h>
   7          #include "watchdog.h"
   8          
   9          #define UART_BUF_LEN  32
  10          #define PWM_PERIOD 10                 //PWM周期（1-255，大=平滑）
  11          #define FADE_STEP 1                   //每次亮度变化步长（1-20，大=快）
  12          #define FADE_INTERVAL 150             //亮度调整间隔（ms）
  13          
  14          #define BEEP_TONE1_FREQ 2000          //低音
  15          #define BEEP_TONE2_FREQ 3000          //中音
  16          #define BEEP_TONE3_FREQ 4000          //高音
  17          #define BEEP_TONE_CHANGE_MS 500
  18          #define BEEP_TOTAL_DURATION 1500
  19          
  20          int keyflag = 0;
  21          int weekflag = 0;
  22          int year = 2026;
  23          int month = 9;
  24          int day = 11;
  25          int hour = 8;
  26          int min = 1;
  27          int sec = 0;
  28          int alarm_hour = 0;
  29          int alarm_min = 0;
  30          int alarm_sec = 5;
  31          
  32          static const char* weekdays[] = {"Mon", "Tue", "Wed", "Thu", "Fri", "Sat","Sun"};
  33          static const u8 max_days[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
  34          
  35          sbit LED1 = P2^4;
  36          sbit LED2 = P2^5;
  37          sbit LED3 = P2^6;
  38          sbit LED4 = P2^7;
  39          
  40          sbit BEEP = P1^0;
  41          
  42          sbit KEY1 = P3^2;     //用于关闭蜂鸣器闹铃
  43          sbit KEY2 = P3^3;     //用于设置闹铃时间
  44          sbit KEY3 = P3^4;     //用于切换数码管显示模式
  45          
  46          bit time_flag = 0;
  47          bit beep_active = 0;
  48          bit uart_cmd_ready = 0;
  49          bit alarm_enabled = 0;                //闹钟使能标志
  50          
  51          u8 beep_state = 0;
  52          u8 i = 0;
  53          u8 uart_buf[UART_BUF_LEN];
  54          u8 uart_buf_idx = 0;
C51 COMPILER V9.60.7.0   MAIN                                                              01/30/2026 14:36:05 PAGE 2   

  55          u8 led_pwm_duty[4];                   //4个LED的PWM占空比
  56          u8 led_pwm_counter = 0;               //PWM计数器（0-99）
  57          u8 fade_direction[4];                 //0渐暗, 1渐亮
  58          u8 active_led = 0;                    //当前活动的LED
  59          u16 led_delay_count = 0;
  60          u16 main_loop_counter = 0;
  61          u16 beep_duration = 0;                //蜂鸣器持续时间（毫秒）
  62          u8 beep_freq_counter = 0;
  63          u8 beep_freq_target = 0;
  64          
  65          //函数声明
  66          void UART_SendChar(char ch);
  67          void UART_SendString(char *str);
  68          void UART_ExceptYear(int num);
  69          void UART_Year(int Year);
  70          void UART_SendAllMessage(void);
  71          void Date_Update(void);
  72          void UART_ParseCmd(void);             //解析串口指令
  73          
  74          
  75          void delay_10us_loop(u8 n) {
  76   1          while(n--) {
  77   2              _nop_(); _nop_(); _nop_(); _nop_(); _nop_();
  78   2              _nop_(); _nop_(); _nop_(); _nop_(); _nop_();
  79   2          }
  80   1      }
  81          
  82          void generate_tone(u8 freq_index) {
  83   1          u8 i, j;
  84   1          u8 delay_val;
  85   1          
  86   1          switch(freq_index) {
  87   2              case 1:
  88   2                  delay_val = 25;
  89   2                  for(j = 0; j < 2; j++) {
  90   3                      BEEP = ~BEEP;
  91   3                      delay_10us_loop(delay_val);
  92   3                  }
  93   2                  break;
  94   2                  
  95   2              case 2:
  96   2                  delay_val = 17;
  97   2                  for(j = 0; j < 2; j++) {
  98   3                      BEEP = ~BEEP;
  99   3                      delay_10us_loop(delay_val);
 100   3                  }
 101   2                  break;
 102   2                  
 103   2              case 3:
 104   2                  delay_val = 12;
 105   2                  for(j = 0; j < 2; j++) {
 106   3                      BEEP = ~BEEP;
 107   3                      delay_10us_loop(delay_val);
 108   3                  }
 109   2                  break;
 110   2          }
 111   1      }
*** WARNING C280 IN LINE 83 OF main.c: 'i': unreferenced local variable
 112          
 113          //数码管显时模块
 114          void smg_display (DisplayMode current_mode) {
 115   1          u8 num[4];
C51 COMPILER V9.60.7.0   MAIN                                                              01/30/2026 14:36:05 PAGE 3   

 116   1          static u8 display_count = 0;
 117   1          static u8 current_digit = 0;
 118   1          if (current_mode == display_time) {
 119   2              num[0] = hour / 10;
 120   2              num[1] = hour % 10;
 121   2              num[2] = min / 10;
 122   2              num[3] = min % 10;
 123   2          }
 124   1          else if (current_mode == display_date) {
 125   2              num[0] = month / 10;
 126   2              num[1] = month % 10;
 127   2              num[2] = day / 10;
 128   2              num[3] = day % 10;
 129   2          }
 130   1      
 131   1          if(display_count >= 2) {
 132   2              display_count = 0;
 133   2              SEL0 = 1;
 134   2              SEL1 = 1;
 135   2              SEL2 = 1;
 136   2              SEL3 = 1;
 137   2      
 138   2              SMG_ADP = gsmg_code[num[current_digit]];
 139   2      
 140   2              switch(current_digit) {
 141   3                  case 0: SEL0 = 0; break;
 142   3                  case 1: SEL1 = 0; break;
 143   3                  case 2: SEL2 = 0; break;
 144   3                  case 3: SEL3 = 0; break;
 145   3              }
 146   2      
 147   2              current_digit++;
 148   2              if(current_digit >= 4) {
 149   3                  current_digit = 0;
 150   3              }
 151   2          } 
 152   1          else{
 153   2             display_count++;
 154   2          }
 155   1      }
 156          
 157          //中断器初始化
 158          static void InitInterrupt() {
 159   1        ET0 = 1;
 160   1        ES = 1;
 161   1        EA = 1;
 162   1      }
 163          
 164          DisplayMode current_mode = display_time;
 165          
 166          //定时器初始化
 167          void InitTimer0(void) {
 168   1        TMOD = 0x21;
 169   1        TH0 = 0xFC;
 170   1        TL0 = 0x18;
 171   1        TR0 = 1;
 172   1      }
 173          
 174          //按键3检测
 175          u8 KEY3_Detect(void) {
 176   1          static u8 key_not_pressed = 1;
 177   1          if(key_not_pressed && (KEY3 == 0)) {
C51 COMPILER V9.60.7.0   MAIN                                                              01/30/2026 14:36:05 PAGE 4   

 178   2              delay_10us(100);
 179   2              if(KEY3 == 0) {
 180   3                 key_not_pressed = 0;
 181   3                 return 1;
 182   3              }
 183   2          }
 184   1          else if(KEY3 == 1) {
 185   2              key_not_pressed = 1;
 186   2          }
 187   1          return 0;
 188   1      }
 189          
 190          //切换显示模式
 191          void DisplayMode_Switch(void) {
 192   1          if(current_mode == display_time) {
 193   2              current_mode = display_date;
 194   2          }
 195   1          else {
 196   2              current_mode = display_time;
 197   2          }
 198   1      }
 199          
 200          //串口初始化
 201          static void InitUART(void) {        //4800波特率（开倍增0X80,不开0X00）
 202   1          SCON = 0X50;
 203   1          PCON = 0X80;
 204   1          TL1  = 0XF3;
 205   1          TH1  = TL1;
 206   1          TR1  = 1;
 207   1      }
 208          
 209          //日期更新逻辑
 210          void Date_Update(void) {
 211   1          static const u8 max_days[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
 212   1          
 213   1          if(day > max_days[month-1]) {
 214   2              day = 1;
 215   2              month++;
 216   2              if(month > 12) {
 217   3                  month = 1;
 218   3                  year++;
 219   3              }
 220   2          }
 221   1      }
 222          
 223          //EEPROM读取
 224          void IAP_Assignment(void){
 225   1        sec = IAPByteRead(0x2000);
 226   1        min = IAPByteRead(0x2001);
 227   1        hour = IAPByteRead(0x2002);
 228   1        day = IAPByteRead(0x2003);
 229   1        month = IAPByteRead(0x2004);
 230   1        year = IAPByteRead(0x2005) * 256 + IAPByteRead(0x2006);
 231   1        weekflag = IAPByteRead(0x2007);
 232   1      }
 233          
 234          //EEPROM写入
 235          void IAP_Write(void){
 236   1        IAPByteWrite(0x2000,sec); 
 237   1        IAPByteWrite(0x2001,min); 
 238   1        IAPByteWrite(0x2002,hour); 
 239   1        IAPByteWrite(0x2003,day); 
C51 COMPILER V9.60.7.0   MAIN                                                              01/30/2026 14:36:05 PAGE 5   

 240   1        IAPByteWrite(0x2004,month); 
 241   1        IAPByteWrite(0x2005, year / 256);    // 高字节
 242   1        IAPByteWrite(0x2006, year % 256);    // 低字节
 243   1        IAPByteWrite(0x2007,weekflag); 
 244   1      }
 245          
 246          u8 data_valid=0;
 247          
 248          
 249          //主函数
 250          void main(void) {
 251   1          WDT_INIT();           //放狗
 252   1          WDT_FEED();           //喂狗
 253   1        
 254   1          SMG_Init();
 255   1          InitTimer0();
 256   1          InitUART();
 257   1          InitInterrupt();
 258   1        
 259   1          BEEP = 1;
 260   1          alarm_enabled = 0;
 261   1        
 262   1          //验证数据有效性
 263   1          data_valid = IAPByteRead(0x2200);
 264   1          if(data_valid == 0x01) {
 265   2              IAP_Assignment();
 266   2              UART_SendString("Restored time from EEPROM\r\n");
 267   2          }
 268   1          else {
 269   2              UART_SendString("Using preset time\r\n");
 270   2              IAPSectorErase(0x2000);
 271   2              IAP_Write();
 272   2            
 273   2              IAPSectorErase(0x2200);
 274   2              IAPByteWrite(0x2200, 0x01);
 275   2          }
 276   1          
 277   1          
 278   1          LED1 = LED2 = LED3 = LED4 = 1;
 279   1          for(i = 0; i < 4; i++) {
 280   2             led_pwm_duty[i] = 0;
 281   2             fade_direction[i] = 0;
 282   2          }
 283   1          active_led = 0;
 284   1          
 285   1          
 286   1          while(1){
 287   2            main_loop_counter++;
 288   2            smg_display(current_mode);
 289   2            
 290   2            if(uart_cmd_ready) {
 291   3              uart_cmd_ready = 0;
 292   3              UART_ParseCmd();
 293   3              UART_SendAllMessage();
 294   3            }
 295   2      
 296   2      
 297   2            //LED流水灯（PWM改进）
 298   2            if(++led_delay_count >= FADE_INTERVAL) {
 299   3               led_delay_count = 0;
 300   3                  
 301   3               for(i = 0; i < 4; i++) {
C51 COMPILER V9.60.7.0   MAIN                                                              01/30/2026 14:36:05 PAGE 6   

 302   4                   if(i == active_led) {
 303   5                      if(fade_direction[i] == 0) {
 304   6                         if(led_pwm_duty[i] < (PWM_PERIOD - 1)) {
 305   7                             led_pwm_duty[i] += FADE_STEP;
 306   7                         }
 307   6                         else 
 308   6                         {
 309   7                            fade_direction[i] = 1;
 310   7                         }
 311   6                      }
 312   5                      else 
 313   5                      {
 314   6                         if(led_pwm_duty[i] > 0) {
 315   7                             led_pwm_duty[i] -= FADE_STEP;
 316   7                         }
 317   6                         else 
 318   6                         {
 319   7                             fade_direction[i] = 0;
 320   7                             active_led = (active_led + 1) % 4;
 321   7                         }
 322   6                      }
 323   5                    }
 324   4                    else
 325   4                    {
 326   5                      if(led_pwm_duty[i] > 0) {
 327   6                          if(led_pwm_duty[i] > 2) {
 328   7                              led_pwm_duty[i] -= 2;
 329   7                          }
 330   6                      } 
 331   5                      else 
 332   5                      {
 333   6                          led_pwm_duty[i] = 0;
 334   6                      }
 335   5                    }
 336   4                }
 337   3            }//以上。
 338   2      
 339   2            //时间处理标志位
 340   2            if(time_flag == 1){
 341   3              time_flag=0;
 342   3              UART_SendAllMessage();
 343   3              WDT_DISABLE();      //拴狗
 344   3              IAPSectorErase(0x2000);           //擦除起始地址为0x2000的扇区
 345   3              IAP_Write();                      //对起始地址为0x2000的扇区写入寄存器的值
 346   3              WDT_ENABLE();       //解狗绳
 347   3            }
 348   2            
 349   2            //蜂鸣器闹钟模块（加入变调）
 350   2            if(alarm_enabled && keyflag == 0 && !beep_active) {
 351   3               if(hour == alarm_hour && min == alarm_min && sec >= alarm_sec) {
 352   4                  beep_active = 1;
 353   4                  beep_duration = 0;
 354   4                  beep_state = 0;
 355   4                  beep_freq_target = 1;
 356   4               }
 357   3             }
 358   2            if(beep_active) {
 359   3                if(beep_duration < BEEP_TONE_CHANGE_MS) {
 360   4                    beep_freq_target = 1;  //低音
 361   4                }
 362   3                else if(beep_duration < (BEEP_TONE_CHANGE_MS * 2)) {
 363   4                    WDT_FEED();           //喂狗
C51 COMPILER V9.60.7.0   MAIN                                                              01/30/2026 14:36:05 PAGE 7   

 364   4                    beep_freq_target = 2;  //中音
 365   4                }
 366   3                else {
 367   4                    beep_freq_target = 3;  //高音
 368   4                  
 369   4                }
 370   3                generate_tone(beep_freq_target);
 371   3                beep_duration++;
 372   3                if(beep_duration >= BEEP_TOTAL_DURATION) {
 373   4                    beep_active = 0;
 374   4                    BEEP = 1;
 375   4                    keyflag = 1;
 376   4                }
 377   3                //按键停止
 378   3                if(KEY1 == 0) {
 379   4                    delay_10us(1000);
 380   4                    if(KEY1 == 0) {
 381   5                        beep_active = 0;
 382   5                        BEEP = 1;
 383   5                        keyflag = 1;
 384   5                        while(KEY1 == 0) {
 385   6                           smg_display(current_mode);
 386   6                        }   
 387   5                    }
 388   4                 }    
 389   3            }//以上。
 390   2            main_loop_counter++;
 391   2              //KEY3检测
 392   2              if(KEY3_Detect()) {
 393   3                DisplayMode_Switch();
 394   3              }
 395   2          }
 396   1      }
 397          
 398          
 399          
 400          //定时器中断
 401          void Timer0_Interrupt(void) interrupt 1 {
 402   1          static u16 count = 0;
 403   1          static u8 pwm_count = 0;
 404   1          static u16 wdt_count = 0;
 405   1        
 406   1          TH0 = 0xFC;
 407   1          TL0 = 0x18;
 408   1        
 409   1          //看门狗（主循环正常才喂狗）
 410   1          if(++wdt_count >= 100) {
 411   2             wdt_count = 0;
 412   2          
 413   2             if(main_loop_counter < 2) {
 414   3               
 415   3             }
 416   2             else {
 417   3              main_loop_counter = 0;
 418   3              WDT_FEED();
 419   3             }
 420   2          }//以上。
 421   1        
 422   1          count++;
 423   1        
 424   1          if(count >= 1000) {
 425   2            count = 0;
C51 COMPILER V9.60.7.0   MAIN                                                              01/30/2026 14:36:05 PAGE 8   

 426   2            sec++;
 427   2            if(sec >= 60){
 428   3              sec=0;
 429   3              min++;
 430   3              if(min >= 60){
 431   4                min=0;
 432   4                hour++;
 433   4                if(hour >= 24){
 434   5                  hour=0;
 435   5                  day++;
 436   5                  weekflag++;
 437   5                  if(day > max_days[month-1]) {
 438   6                     day = 1;
 439   6                     month++;
 440   6                     if(month > 12) {
 441   7                        month = 1;
 442   7                        year++;
 443   7                     }
 444   6                  }
 445   5                }
 446   4              }
 447   3            }
 448   2            time_flag=1;
 449   2          }
 450   1          //LED呼吸灯实现
 451   1          pwm_count++;
 452   1          if(pwm_count >= PWM_PERIOD) {
 453   2              pwm_count = 0;
 454   2          }
 455   1          LED1 = (led_pwm_duty[0] > pwm_count) ? 0 : 1;
 456   1          LED2 = (led_pwm_duty[1] > pwm_count) ? 0 : 1;
 457   1          LED3 = (led_pwm_duty[2] > pwm_count) ? 0 : 1;
 458   1          LED4 = (led_pwm_duty[3] > pwm_count) ? 0 : 1;
 459   1      }
 460          
 461          
 462          //串口中断
 463          void UART_Handler() interrupt 4 {
 464   1          u8 ch;
 465   1          if (RI){
 466   2          
 467   2          ch = SBUF;
 468   2          if(uart_buf_idx < UART_BUF_LEN-1 && ch != '\n') {
 469   3            uart_buf[uart_buf_idx++] = ch;
 470   3          }
 471   2          if(ch == '\n') {
 472   3            uart_buf[uart_buf_idx] = '\0';
 473   3            uart_buf_idx = 0;
 474   3            uart_cmd_ready = 1;
 475   3          }
 476   2          
 477   2          RI=0;
 478   2        }
 479   1      }
 480          
 481          //串口打印（简化）
 482          void UART_Print(char *str) {
 483   1          while (*str) {
 484   2              UART_SendChar(*str);
 485   2              str++;
 486   2          }
 487   1      }
C51 COMPILER V9.60.7.0   MAIN                                                              01/30/2026 14:36:05 PAGE 9   

 488          
 489          //串口发送字符
 490          void UART_SendChar(char ch){
 491   1          SBUF = ch;
 492   1          while(!TI){
 493   2             smg_display(current_mode);
 494   2          }
 495   1          TI = 0; 
 496   1      }
 497          
 498          //串口发送字符串
 499          void UART_SendString(char *str){
 500   1          while(*str != '\0'){
 501   2            UART_SendChar(*str);
 502   2            str++;
 503   2          }
 504   1      }
 505          
 506          //串口发送年份以外信息（月日，十分，星期几）
 507          void UART_ExceptYear(int num){
 508   1          UART_SendChar((num / 10) + '0');
 509   1          UART_SendChar((num % 10) + '0');
 510   1      }
 511          
 512          //串口发送年份
 513          void UART_Year(int Year){
 514   1          UART_SendChar((Year / 1000) % 10 + '0');
 515   1          UART_SendChar((Year / 100) % 10 + '0');
 516   1          UART_SendChar((Year / 10) % 10 + '0');
 517   1          UART_SendChar(Year % 10 + '0');
 518   1      }
 519          
 520          //串口打包发送全部时间信息
 521          void UART_SendAllMessage(void){
 522   1          UART_Year(year);
 523   1          UART_SendChar('-');
 524   1        
 525   1          UART_ExceptYear(month);
 526   1          UART_SendChar('-');
 527   1        
 528   1          UART_ExceptYear(day);
 529   1          UART_SendString("  "); 
 530   1        
 531   1          UART_ExceptYear(hour);
 532   1          UART_SendChar(':');
 533   1        
 534   1          UART_ExceptYear(min);
 535   1          UART_SendChar(':');
 536   1        
 537   1          UART_ExceptYear(sec);
 538   1          UART_SendChar(' ');
 539   1        
 540   1          UART_SendString(weekdays[(weekflag + 3) % 7]);        //根据2026年历
 541   1          UART_SendChar('\r');
 542   1        
 543   1          UART_SendChar('\n');
 544   1          
 545   1      }
 546          
 547          //更改时间指令解析（格式：set:YYYY-MM-DD HH:MM:SS）
 548          //设置闹钟指令解析（格式：alarm:HH-MM-SS）
 549          void UART_ParseCmd(void) {
C51 COMPILER V9.60.7.0   MAIN                                                              01/30/2026 14:36:05 PAGE 10  

 550   1          if (strncmp(uart_buf, "set:", 4) == 0) 
 551   1          {
 552   2              year = (uart_buf[4]-'0')*1000 + (uart_buf[5]-'0')*100 + (uart_buf[6]-'0')*10 + (uart_buf[7]-'0');
 553   2              month = (uart_buf[9]-'0')*10 + (uart_buf[10]-'0');
 554   2              day = (uart_buf[12]-'0')*10 + (uart_buf[13]-'0');
 555   2              hour = (uart_buf[15]-'0')*10 + (uart_buf[16]-'0');
 556   2              min = (uart_buf[18]-'0')*10 + (uart_buf[19]-'0');
 557   2              sec = (uart_buf[21]-'0')*10 + (uart_buf[22]-'0');
 558   2              
 559   2              UART_SendString("Time updated\r\n");
 560   2          }
 561   1          else if (strncmp(uart_buf, "alarm:", 6) == 0) 
 562   1          {
 563   2              alarm_hour = (uart_buf[6]-'0')*10 + (uart_buf[7]-'0');
 564   2              alarm_min = (uart_buf[9]-'0')*10 + (uart_buf[10]-'0');
 565   2              alarm_sec = (uart_buf[12]-'0')*10 + (uart_buf[13]-'0');
 566   2              alarm_enabled = 1;
 567   2              keyflag = 0;
 568   2              
 569   2              UART_SendString("Alarm set to: ");
 570   2              UART_ExceptYear(alarm_hour);
 571   2              UART_SendChar(':');
 572   2              UART_ExceptYear(alarm_min);
 573   2              UART_SendChar(':');
 574   2              UART_ExceptYear(alarm_sec);
 575   2              UART_SendString("\r\n");
 576   2          }
 577   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2889    ----
   CONSTANT SIZE    =    124    ----
   XDATA SIZE       =    130      15
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
